#include <iostream>
#include <unistd.h>
#include <ncurses.h>
#include <sys/ioctl.h>
#include <vector>
#include <random>
#include <thread>
#include <chrono>
#include <atomic>
#include <mutex>
std::random_device rd;std::mt19937 gen(rd());int l, c, fr;double fp;std::atomic<bool> sT(false);std::mutex sTM;std::mutex cM;std::mutex sM;struct P {char b, bs[4];int dX, dY, paX, paY, pX, pY;};struct F{char b = '@';int pX, pY;};class S {std::vector<std::vector<char>>& co;std::uniform_int_distribution<int> diX;std::uniform_int_distribution<int> diY;public:int l, c, sc;bool fC, gO;char bB = '#';F f;std::vector<P> p;S(std::vector<std::vector<char>>& vec, const P h) : co(vec), diX(0, vec[0].size() - 1), diY(0, vec.size() - 1) { l = vec.size(); c = vec[0].size(); p.push_back(h);}void n() { switch (p[0].dX){ case 1: p[0].b = p[0].bs[3]; break; case -1: p[0].b = p[0].bs[2]; break; } switch (p[0].dY){ case 1: p[0].b = p[0].bs[1]; break; case -1: p[0].b = p[0].bs[0]; break; } co[p[0].pY][p[0].pX] = p[0].b; if (p[0].dY == 0){ if ((p[0].pX == 0) && (p[0].dX == -1)) { if (co[p[0].pY][c - 1] == bB){ gO = true; } if (co[p[0].pY][c - 1] == f.b){ co[f.pY][f.pX] = ' '; fC = true; } co[p[0].pY][p[0].pX] ^= co[p[0].pY][c - 1]; co[p[0].pY][c - 1] ^= co[p[0].pY][p[0].pX]; co[p[0].pY][p[0].pX] ^= co[p[0].pY][c - 1]; p[0].pX = c - 1; } else if (((p[0].pX + 1) == c) && (p[0].dX == 1)) { if (co[p[0].pY][0] == bB){ gO = true; } if (co[p[0].pY][0] == f.b){ co[f.pY][f.pX] = ' '; fC = true; } co[p[0].pY][p[0].pX] ^= co[p[0].pY][0]; co[p[0].pY][0] ^= co[p[0].pY][p[0].pX]; co[p[0].pY][p[0].pX] ^= co[p[0].pY][0]; p[0].pX = 0; } else{ if (co[p[0].pY][p[0].pX + p[0].dX] == bB){ gO = true; } if (co[p[0].pY][p[0].pX + p[0].dX] == f.b){ co[f.pY][f.pX] = ' '; fC = true; } co[p[0].pY][p[0].pX] ^= co[p[0].pY][p[0].pX + p[0].dX]; co[p[0].pY][p[0].pX + p[0].dX] ^= co[p[0].pY][p[0].pX]; co[p[0].pY][p[0].pX] ^= co[p[0].pY][p[0].pX + p[0].dX]; p[0].pX += p[0].dX; } } else if(p[0].dX == 0){ if ((p[0].pY == 0) && (p[0].dY == -1)) { if (co[l - 1][p[0].pX] == bB){ gO = true; } if (co[l - 1][p[0].pX] == f.b){ co[f.pY][f.pX] = ' '; fC = true; } co[p[0].pY][p[0].pX] ^= co[l - 1][p[0].pX]; co[l - 1][p[0].pX] ^= co[p[0].pY][p[0].pX]; co[p[0].pY][p[0].pX] ^= co[l - 1][p[0].pX]; p[0].pY = l - 1; } else if (((p[0].pY + 1) == l) && (p[0].dY == 1)) { if (co[0][p[0].pX] == bB){ gO = true; } if (co[0][p[0].pX] == f.b){ co[f.pY][f.pX] = ' '; fC = true; } co[p[0].pY][p[0].pX] ^= co[0][p[0].pX]; co[0][p[0].pX] ^= co[p[0].pY][p[0].pX]; co[p[0].pY][p[0].pX] ^= co[0][p[0].pX]; p[0].pY = 0; } else{ if (co[p[0].pY + p[0].dY][p[0].pX] == bB){ gO = true; } if (co[p[0].pY + p[0].dY][p[0].pX] == f.b){ co[f.pY][f.pX] = ' '; fC = true; } co[p[0].pY][p[0].pX] ^= co[p[0].pY + p[0].dY][p[0].pX]; co[p[0].pY + p[0].dY][p[0].pX] ^= co[p[0].pY][p[0].pX]; co[p[0].pY][p[0].pX] ^= co[p[0].pY + p[0].dY][p[0].pX]; p[0].pY += p[0].dY; } }}void n2() { for (int i = 1; i < p.size(); i++){ if (p[i - 1].paY == 0){ if ((p[i].pX == 0) && (p[i - 1].paX == -1)) { co[p[i].pY][p[i].pX] ^= co[p[i].pY][c - 1]; co[p[i].pY][c - 1] ^= co[p[i].pY][p[i].pX]; co[p[i].pY][p[i].pX] ^= co[p[i].pY][c - 1]; p[i].pX = c - 1; } else if (((p[i].pX + 1) == c) && (p[i - 1].paX == 1)) { co[p[i].pY][p[i].pX] ^= co[p[i].pY][0]; co[p[i].pY][0] ^= co[p[i].pY][p[i].pX]; co[p[i].pY][p[i].pX] ^= co[p[i].pY][0]; p[i].pX = 0; } else{ co[p[i].pY][p[i].pX] ^= co[p[i].pY][p[i].pX + p[i - 1].paX]; co[p[i].pY][p[i].pX + p[i - 1].paX] ^= co[p[i].pY][p[i].pX]; co[p[i].pY][p[i].pX] ^= co[p[i].pY][p[i].pX + p[i - 1].paX]; p[i].pX += p[i - 1].paX; } } else if (p[i - 1].paX == 0){ if ((p[i].pY == 0) && (p[i - 1].paY == -1)) { co[p[i].pY][p[i].pX] ^= co[l - 1][p[i].pX]; co[l - 1][p[i].pX] ^= co[p[i].pY][p[i].pX]; co[p[i].pY][p[i].pX] ^= co[l - 1][p[i].pX]; p[i].pY = l - 1; } else if (((p[i].pY + 1) == l) && (p[i - 1].paY == 1)) { co[p[i].pY][p[i].pX] ^= co[0][p[i].pX]; co[0][p[i].pX] ^= co[p[i].pY][p[i].pX]; co[p[i].pY][p[i].pX] ^= co[0][p[i].pX]; p[i].pY = 0; } else{ co[p[i].pY][p[i].pX] ^= co[p[i].pY + p[i - 1].paY][p[i].pX]; co[p[i].pY + p[i - 1].paY][p[i].pX] ^= co[p[i].pY][p[i].pX]; co[p[i].pY][p[i].pX] ^= co[p[i].pY + p[i - 1].paY][p[i].pX]; p[i].pY += p[i - 1].paY; } } p[i].paX = p[i].dX; p[i].paY = p[i].dY; p[i].dX = p[i - 1].paX; p[i].dY = p[i - 1].paY; } p[0].paX = p[0].dX; p[0].paY = p[0].dY;}void gB() { int cS = p.size() - 1; P bo; bo.b = bB; bo.dX = p[cS].paX; bo.dY = p[cS].paY; bo.pX = p[cS].pX - p[cS].dX; bo.pY = p[cS].pY - p[cS].dY; co[bo.pY][bo.pX] = bo.b; p.push_back(bo);}void gF() { int pX, pY; do{ pX = diX(gen); pY = diY(gen); }while(co[pY][pX] != ' '); f.pX = pX; f.pY = pY; co[pY][pX] = f.b;}void cFI() { if (fC) { sc++; gB(); gF(); fC = false; }}};bool gTS() {struct winsize ws;if (ioctl(STDOUT_FILENO, TIOCGWINSZ, & ws) != -1) { c = ws.ws_col - 1; l = ws.ws_row - 1; return true;} else { std::cerr << "Error retrieving terminal information." << std::endl; return false;}}void dP(const std::vector<std::vector<char>> & co, S& s) {std::chrono::steady_clock::time_point lFT = std::chrono::steady_clock::now();while (!sT) { { std::unique_lock <std::mutex> l1(cM); clear(); for (int i = 0; i < l; i++) { for (int j = 0; j < c; j++) { printw("%c", co[i][j]); } printw("\n"); } } { std::unique_lock<std::mutex> l2(sM); printw("Score: %d ", s.sc); } fr++; std::chrono::steady_clock::time_point cT = std::chrono::steady_clock::now(); std::chrono::duration < double > eS = cT - lFT; if (eS.count() >= 1.0) { fp = fr / eS.count(); lFT = cT; fr = 0; } printw("FPS: %.2f\n", fp); refresh(); std::this_thread::sleep_for(std::chrono::milliseconds(10));}}void iT(S& s) {int ch;while (!sT) { ch = getch(); { std::unique_lock<std::mutex> l2(sM); switch (ch) { case 27: { std::unique_lock<std::mutex> l0(sTM); sT.store(true); } break; case KEY_LEFT: if (s.p[0].dX != 1){ s.p[0].dX = -1; s.p[0].dY = 0; } break; case KEY_UP: if (s.p[0].dY != 1){ s.p[0].dX = 0; s.p[0].dY = -1; } break; case KEY_RIGHT: if (s.p[0].dX != -1){ s.p[0].dX = 1; s.p[0].dY = 0; } break; case KEY_DOWN: if (s.p[0].dY != -1){ s.p[0].dX = 0; s.p[0].dY = 1; } break; } }}}int main() {if (!gTS()) { return 1; }P h = { .bs = {'^', 'v', '<', '>'}, .dX = 0, .dY = -1, .pX = c / 2, .pY = l / 2};std::vector<std::vector<char>> co(l, std::vector<char>(c, ' '));S s(std::ref(co), h);initscr();cbreak();keypad(stdscr, TRUE);std::thread d(dP, std::ref(co), std::ref(s));std::thread in(iT, std::ref(s));s.gF();while (!sT) { { std::unique_lock <std::mutex> l1(cM); std::unique_lock<std::mutex> l2(sM); s.n(); s.n2(); s.cFI(); if (s.gO) { {std::unique_lock<std::mutex> l0(sTM);sT.store(true);} } } std::this_thread::sleep_for(std::chrono::milliseconds(100));}d.join();in.join();endwin();if (s.gO){ std::vector<std::string> gOMs = { "Snake decided to play Twister with itself and lost. Game over!", "Oops! Snake thought it was a donut and took a bite out of itself. Game over.", "Snake tried to be fancy and perform a tail-knotting trick. It didn't end well. Game over!", "Looks like the snake was its own worst enemy. Game over!", "Snake got a little too hungry and mistook its tail for a snack. Game over.", "Snake's attempt at a self-hug didn't go as planned. Game over!" }; std::uniform_int_distribution<int> dist(0, gOMs.size() - 1); int rI = dist(gen); std::cout << gOMs[rI] << std::endl; std::cout << "Score: " << s.sc << std::endl;} else{std::cout << "Exited.." << std::endl;}return 0;}